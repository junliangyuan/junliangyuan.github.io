
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>IOS中数据持久化方式 | 袁俊亮技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="IOS中数据持久化方式标签（空格分隔）： IOS

[TOC]
概论所谓的数据持久化，就是将数据保存到硬盘中，是的应用程序或机器重启后可以继续访问。IOS中数据持久化常用的有5种方案

plist(属性列表)
preference(偏好设置)
NSKeyedArchiver(归档)
SQLite3
CoreData

沙盒在介绍各种存储方法之前，有必要说明以下沙盒机制。iOS程序默认情况下只能访问">
<meta property="og:type" content="article">
<meta property="og:title" content="IOS中数据持久化方式">
<meta property="og:url" content="http://yoursite.com/2016/06/08/IOS/IOS中数据持久化方式/index.html">
<meta property="og:site_name" content="袁俊亮技术博客">
<meta property="og:description" content="IOS中数据持久化方式标签（空格分隔）： IOS

[TOC]
概论所谓的数据持久化，就是将数据保存到硬盘中，是的应用程序或机器重启后可以继续访问。IOS中数据持久化常用的有5种方案

plist(属性列表)
preference(偏好设置)
NSKeyedArchiver(归档)
SQLite3
CoreData

沙盒在介绍各种存储方法之前，有必要说明以下沙盒机制。iOS程序默认情况下只能访问">
<meta property="og:updated_time" content="2016-06-08T01:37:44.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IOS中数据持久化方式">
<meta name="twitter:description" content="IOS中数据持久化方式标签（空格分隔）： IOS

[TOC]
概论所谓的数据持久化，就是将数据保存到硬盘中，是的应用程序或机器重启后可以继续访问。IOS中数据持久化常用的有5种方案

plist(属性列表)
preference(偏好设置)
NSKeyedArchiver(归档)
SQLite3
CoreData

沙盒在介绍各种存储方法之前，有必要说明以下沙盒机制。iOS程序默认情况下只能访问">
  
    <link rel="alternative" href="/atom.xml" title="袁俊亮技术博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">袁俊亮技术博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">不积跬步无以至千里</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-IOS/IOS中数据持久化方式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/08/IOS/IOS中数据持久化方式/" class="article-date">
  <time datetime="2016-06-08T01:37:44.000Z" itemprop="datePublished">2016-06-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/IOS/">IOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      IOS中数据持久化方式
    </h1>
  

      </header>
    
<div class="article-entry" itemprop="articleBody">
  
    
    
      <h1 id="IOS中数据持久化方式"><a href="#IOS中数据持久化方式" class="headerlink" title="IOS中数据持久化方式"></a>IOS中数据持久化方式</h1><p>标签（空格分隔）： IOS</p>
<hr>
<p>[TOC]</p>
<h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p>所谓的数据持久化，就是将数据保存到硬盘中，是的应用程序或机器重启后可以继续访问。IOS中数据持久化常用的有5种方案</p>
<ul>
<li>plist(属性列表)</li>
<li>preference(偏好设置)</li>
<li>NSKeyedArchiver(归档)</li>
<li>SQLite3</li>
<li>CoreData</li>
</ul>
<h2 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h2><p>在介绍各种存储方法之前，有必要说明以下沙盒机制。iOS程序默认情况下只能访问程序自己的目录，这个目录被称为“沙盒”。</p>
<h3 id="1-结构"><a href="#1-结构" class="headerlink" title="1.结构"></a>1.结构</h3><p>既然沙盒就是一个文件夹，沙盒的目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;应用程序包&quot;</span><br><span class="line">Documents</span><br><span class="line">Library</span><br><span class="line">    Caches</span><br><span class="line">    Preferences</span><br><span class="line">temp</span><br></pre></td></tr></table></figure>
<h3 id="2-目录特征"><a href="#2-目录特征" class="headerlink" title="2.目录特征"></a>2.目录特征</h3><p>虽然沙盒中有这么多文件夹，但是每个文件夹都不尽相同，都有各自的特性。所以在选择存放目录时，一定要认真选择适合的目录。</p>
<ul>
<li><code>应用程序包</code>：这里面存放的是应用程序的源文件，包括资源文件和可执行文件。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path = [[<span class="built_in">NSBundle</span> mainBundle] bundlePath];</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Documents</code>：最常用的目录，iTunes同步该应用时会同步此文件夹中的内容，适合存储重要数据。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Library/Caches</code>:iTunes不会同步此文件夹，适合存储体积大，不需要备份的非重要数据。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Library/Preferences</code>:iTunes同步该应用时会同步此文件夹中的内容，通常保存应用的设置信息。</li>
<li><code>tmp</code>：iTunes不会同步此文件夹，系统可能在应用没运行时就删除该目录下的文件，所以此目录适合保存应用中的一些临时文件，用完就删除。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path = <span class="built_in">NSTemporaryDirectory</span>();</span><br></pre></td></tr></table></figure>
<h2 id="plist文件（归档）"><a href="#plist文件（归档）" class="headerlink" title="plist文件（归档）"></a>plist文件（归档）</h2><p>plist文件是讲某些特定的类，通过XML的方式保存在目录中</p>
<ul>
<li>可以被序列化的类型只有如下几种：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span>;</span><br><span class="line"><span class="built_in">NSMutableArray</span>;</span><br><span class="line"><span class="built_in">NSDictionary</span>;</span><br><span class="line"><span class="built_in">NSMutableDictionary</span>;</span><br><span class="line"><span class="built_in">NSData</span>;</span><br><span class="line"><span class="built_in">NSMutableData</span>;</span><br><span class="line"><span class="built_in">NSString</span>;</span><br><span class="line"><span class="built_in">NSMutableString</span>;</span><br><span class="line"><span class="built_in">NSNumber</span>;</span><br><span class="line"><span class="built_in">NSDate</span>;</span><br></pre></td></tr></table></figure>
<h3 id="1-获得文件路径"><a href="#1-获得文件路径" class="headerlink" title="1.获得文件路径"></a>1.获得文件路径</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *fileName = [path stringByAppendingPathComponent:<span class="string">@"123.plist"</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSDocumentDirectory ： 查找Documents文件夹</span><br><span class="line">NSUserDomainMask ： 在用户目录下查找</span><br><span class="line">YES：代表用户目录的~</span><br><span class="line"></span><br><span class="line">stringByAppendingPathComponent：该方法中系统可以自动帮你添加上&apos;/&apos;</span><br></pre></td></tr></table></figure>
<h3 id="2-存储"><a href="#2-存储" class="headerlink" title="2.存储"></a>2.存储</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[<span class="string">@"123"</span>, <span class="string">@"456"</span>, <span class="string">@"789"</span>];</span><br><span class="line">[array writeToFile:fileName atomically:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<h3 id="3-读取"><a href="#3-读取" class="headerlink" title="3.读取"></a>3.读取</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *result = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:fileName];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, result);</span><br></pre></td></tr></table></figure>
<h3 id="4-注意"><a href="#4-注意" class="headerlink" title="4.注意"></a>4.注意</h3><ul>
<li>只有以上列出的类型才能使用plist文件存储</li>
<li>存储时使用<code>writeToFile: atomically:</code>方法。其中<code>atomically</code>表示原子性，即是否需要先写入一个辅助文件，再把辅助文件拷贝到目标文件地址。这是更安全的写入文件方法，一般都写YES</li>
<li>读取时使用<code>arrayWithContentsOfFile:</code>方法</li>
</ul>
<h2 id="Preference（偏好设置）"><a href="#Preference（偏好设置）" class="headerlink" title="Preference（偏好设置）"></a>Preference（偏好设置）</h2><h3 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1.使用方法"></a>1.使用方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获得NSUserDefaults文件</span></span><br><span class="line"><span class="built_in">NSUserDefaults</span> *userDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.向文件中写入内容</span></span><br><span class="line">[userDefaults setObject:<span class="string">@"AAA"</span> forKey:<span class="string">@"a"</span>];</span><br><span class="line">[userDefaults setBool:<span class="literal">YES</span> forKey:<span class="string">@"sex"</span>];</span><br><span class="line">[userDefaults setInteger:<span class="number">21</span> forKey:<span class="string">@"age"</span>];</span><br><span class="line"><span class="comment">//2.1立即同步</span></span><br><span class="line">[userDefaults synchronize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.读取文件</span></span><br><span class="line"><span class="built_in">NSString</span> *name = [userDefaults objectForKey:<span class="string">@"a"</span>];</span><br><span class="line"><span class="built_in">BOOL</span> sex = [userDefaults boolForKey:<span class="string">@"sex"</span>];</span><br><span class="line"><span class="built_in">NSInteger</span> age = [userDefaults integerForKey:<span class="string">@"age"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@, %d, %ld"</span>, name, sex, age);</span><br></pre></td></tr></table></figure>
<h3 id="2-注意"><a href="#2-注意" class="headerlink" title="2.注意"></a>2.注意</h3><ul>
<li>偏好设置是专门用来保存应用程序的配置信息的，一般不要在偏好设置中保存其他数据。</li>
<li>如果没有调用<code>synchronize</code>方法，系统会根据I/O情况不定时刻地保存到文件中。所以如果需要立即写入文件的就必须调用<code>synchronize</code>方法。</li>
<li>偏好设置会将所有数据保存到同一个文件中。即preference目录下的一个以此应用包名来命名的plist文件。</li>
</ul>
<h2 id="NSKeyedArchiver（NSCoding）"><a href="#NSKeyedArchiver（NSCoding）" class="headerlink" title="NSKeyedArchiver（NSCoding）"></a>NSKeyedArchiver（NSCoding）</h2><p><strong>归档</strong>在iOS中是另一种形式的序列化，只要遵循了NSCoding协议的对象都可以通过它实现序列化。由于决大多数支持存储数据的Foundation和Cocoa Touch类都遵循了NSCoding协议，因此，对于大多数类来说，归档相对而言还是比较容易实现的。Preference和plist文件都无法保存自定义对象，但是NSKeyedArchiver可以保存自定义对象</p>
<h3 id="1-准守NSCoding协议"><a href="#1-准守NSCoding协议" class="headerlink" title="1.准守NSCoding协议"></a>1.准守NSCoding协议</h3><p><code>NSCoding</code>协议声明了两个方法，这两个方法都是必须实现的。一个用来说明如何将对象编码到归档中，另一个说明如何进行解档来获取一个新对象。</p>
<ul>
<li>遵循协议和设置属性</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.遵循NSCoding协议 </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.设置属性</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIImage</span> *avatar;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>实现协议方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解档：读取文件中的对象</span></span><br><span class="line"><span class="comment">// 在该方法中说明读取保存在文件中的对象的哪些属性</span></span><br><span class="line"> - (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123;</span><br><span class="line">     <span class="keyword">if</span> ([<span class="keyword">super</span> init]) &#123;</span><br><span class="line">         <span class="keyword">self</span>.avatar = [aDecoder decodeObjectForKey:<span class="string">@"avatar"</span>];</span><br><span class="line">         <span class="keyword">self</span>.name = [aDecoder decodeObjectForKey:<span class="string">@"name"</span>];</span><br><span class="line">         <span class="keyword">self</span>.age = [aDecoder decodeIntegerForKey:<span class="string">@"age"</span>];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//归档：保存对象到文件时调用</span></span><br><span class="line"> <span class="comment">// 在该方法中说明存储自定义对象的那些属性</span></span><br><span class="line"> - (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder &#123;</span><br><span class="line">     [aCoder encodeObject:<span class="keyword">self</span>.avatar forKey:<span class="string">@"avatar"</span>];</span><br><span class="line">     [aCoder encodeObject:<span class="keyword">self</span>.name forKey:<span class="string">@"name"</span>];</span><br><span class="line">     [aCoder encodeInteger:<span class="keyword">self</span>.age forKey:<span class="string">@"age"</span>];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>特别注意</strong></li>
</ul>
<p>如果需要归档的类是某个自定义类的子类时，就需要在归档和解档之前先实现父类的归档和解档方法。即<code>[super encodeWithCoder:aCoder]</code> 和 <code>[super initWithCoder:aDecoder]</code> 方法;</p>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><ul>
<li>需要把对象归档是调用<code>NSKeyedArchiver</code>的工厂方法 <code>archiveRootObject: toFile:</code> 方法。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *file = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject stringByAppendingPathComponent:<span class="string">@"person.data"</span>];</span><br><span class="line"></span><br><span class="line">  Person *person = [[Person alloc] init];</span><br><span class="line">  person.avatar = <span class="keyword">self</span>.avatarView.image;</span><br><span class="line">  person.name = <span class="keyword">self</span>.nameField.text;</span><br><span class="line">  person.age = [<span class="keyword">self</span>.ageField.text integerValue];</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">NSKeyedArchiver</span> archiveRootObject:person toFile:file];</span><br></pre></td></tr></table></figure>
<ul>
<li>需要从文件中解档对象就调用<code>NSKeyedUnarchiver</code>的一个工厂方法 <code>unarchiveObjectWithFile:</code>即可。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *file = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject stringByAppendingPathComponent:<span class="string">@"person.data"</span>];</span><br><span class="line"></span><br><span class="line">Person *person = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:file];</span><br><span class="line"><span class="keyword">if</span> (person) &#123;</span><br><span class="line">   <span class="keyword">self</span>.avatarView.image = person.avatar;</span><br><span class="line">   <span class="keyword">self</span>.nameField.text = person.name;</span><br><span class="line">   <span class="keyword">self</span>.ageField.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld"</span>, person.age];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除本地归档数据"><a href="#删除本地归档数据" class="headerlink" title="删除本地归档数据"></a>删除本地归档数据</h3><p>使用NSKeyedarchiver存储的数据，当使用NSKeyedUnarchiver读取完数据后。如果有网络的状况下，将数据上传到服务器。如果没有网络，就让数据在本地存储。 如果有网络，则需要将上传后的本地数据删除，以节省本地存储空间。</p>
<p>删除本地归档数据的方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)deleteFiel:(<span class="built_in">NSString</span> *)pathOfFileToDelete error:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> exists = [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:pathOfFileToDelete];</span><br><span class="line">    <span class="keyword">if</span> (exists) &#123;</span><br><span class="line">        [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtPath:pathOfFileToDelete error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>必须遵循并实现NSCoding协议</li>
<li>保存文件的扩展名可以任意指定</li>
<li>继承时必须先调用父类的归档解档方法</li>
</ul>
<h2 id="SQLite3"><a href="#SQLite3" class="headerlink" title="SQLite3"></a>SQLite3</h2><p>之前的所有存储方法，都是覆盖存储。如果想要增加一条数据就必须把整个文件读出来，然后修改数据后再把整个内容覆盖写入文件。所以它们都不适合存储大量的内容。</p>
<h3 id="1-字段类型"><a href="#1-字段类型" class="headerlink" title="1.字段类型"></a>1.字段类型</h3><p>表面上SQLite将数据分为一下几种类型</p>
<ul>
<li>integer：整数</li>
<li>real：实数(浮点数)</li>
<li>text：文本字符串</li>
<li>blob：二进制数据，比如文件，图片之类的</li>
</ul>
<p>实际上SQLite是无类型的。即不管你在创表时指定的字段类型是什么，存储是依然可以存储任意类型的数据。而且在创表时也可以不指定字段类型。SQLite之所以什么类型就是为了良好的编程规范和方便开发人员交流，所以平时在使用时最好设置正确的字段类型！<strong>主键必须设置成integer</strong></p>
<h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2.准备工作"></a>2.准备工作</h3><p>准备工作就是导入依赖库啦，在iOS中要使用SQLite3，需要添加库文件：libsqlite3.dylib并导入主头文件，这是一个C语言的库，所以直接使用SQLite3还是比较麻烦的。</p>
<h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h3><ul>
<li>创建数据库并打开</li>
</ul>
<p>操作数据库之前必须先指定数据库文件和要操作的表，所以使用SQLite3，首先要打开数据库文件，然后指定或创建一张表。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*  打开数据库并创建一个表</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)openDatabase &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1.设置文件名</span></span><br><span class="line">   <span class="built_in">NSString</span> *filename = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject stringByAppendingPathComponent:<span class="string">@"person.db"</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.打开数据库文件，如果没有会自动创建一个文件</span></span><br><span class="line">   <span class="built_in">NSInteger</span> result = sqlite3_open(filename.UTF8String, &amp;_sqlite3);</span><br><span class="line">   <span class="keyword">if</span> (result == SQLITE_OK) &#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"打开数据库成功！"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3.创建一个数据库表</span></span><br><span class="line">       <span class="keyword">char</span> *errmsg = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">       sqlite3_exec(_sqlite3, <span class="string">"CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;errmsg);</span><br><span class="line">       <span class="keyword">if</span> (errmsg) &#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"错误：%s"</span>, errmsg);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"创表成功！"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"打开数据库失败！"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行指令</li>
</ul>
<p>使用 <code>sqlite3_exec()</code> 方法可以执行任何SQL语句，比如创表、更新、插入和删除操作。但是一般不用它执行查询语句，因为它不会返回查询到的数据。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*  往表中插入1000条数据</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)insertData &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *nameStr;</span><br><span class="line"><span class="built_in">NSInteger</span> age;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  nameStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Bourne-%d"</span>, arc4random_uniform(<span class="number">10000</span>)];</span><br><span class="line">  age = arc4random_uniform(<span class="number">80</span>) + <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NSString</span> *sql = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"INSERT INTO t_person (name, age) VALUES('%@', '%ld')"</span>, nameStr, age];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> *errmsg = <span class="literal">NULL</span>;</span><br><span class="line">  sqlite3_exec(_sqlite3, sql.UTF8String, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;errmsg);</span><br><span class="line">  <span class="keyword">if</span> (errmsg) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"错误：%s"</span>, errmsg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"插入完毕！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询指令<br>前面说过一般不使用 <code>sqlite3_exec()</code> 方法查询数据。因为查询数据必须要获得查询结果，所以查询相对比较麻烦。示例代码如下：<ul>
<li>sqlite3_prepare_v2() : 检查sql的合法性</li>
<li>sqlite3_step() : 逐行获取查询结果，不断重复，直到最后一条记录</li>
<li>sqlite3_coloum_xxx() : 获取对应类型的内容，iCol对应的就是SQL语句中字段的顺序，从0开始。根据实际查询字段的属性，使用sqlite3_column_xxx取得对应的内容即可。</li>
<li>sqlite3_finalize() : 释放stmt</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*  从表中读取数据到数组中</span><br><span class="line">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)readData &#123;</span><br><span class="line">   <span class="built_in">NSMutableArray</span> *mArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">1000</span>];</span><br><span class="line">   <span class="keyword">char</span> *sql = <span class="string">"select name, age from t_person;"</span>;</span><br><span class="line">   sqlite3_stmt *stmt;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">NSInteger</span> result = sqlite3_prepare_v2(_sqlite3, sql, <span class="number">-1</span>, &amp;stmt, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">if</span> (result == SQLITE_OK) &#123;</span><br><span class="line">       <span class="keyword">while</span> (sqlite3_step(stmt) == SQLITE_ROW) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">char</span> *name = (<span class="keyword">char</span> *)sqlite3_column_text(stmt, <span class="number">0</span>);</span><br><span class="line">           <span class="built_in">NSInteger</span> age = sqlite3_column_int(stmt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//创建对象</span></span><br><span class="line">           Person *person = [Person personWithName:[<span class="built_in">NSString</span> stringWithUTF8String:name] Age:age];</span><br><span class="line">           [mArray addObject:person];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">self</span>.dataList = mArray;</span><br><span class="line">   &#125;</span><br><span class="line">   sqlite3_finalize(stmt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>总得来说，SQLite3的使用还是比较麻烦的，因为都是些c语言的函数，理解起来有些困难。不过在一般开发过程中，使用的都是第三方开源库<code>FMDB</code>，封装了这些基本的c语言方法，使得我们在使用时更加容易理解，提高开发效率。</p>
<h2 id="FMDB"><a href="#FMDB" class="headerlink" title="FMDB"></a>FMDB</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p><code>FMDB</code>是iOS平台的SQLite数据库框架，它是以OC的方式封装了SQLite的C语言API，它相对于cocoa自带的C语言框架有如下的优点:</p>
<ul>
<li>使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码</li>
<li>对比苹果自带的CoreData框架，更加轻量级和灵活</li>
<li>提供了多线程安全的数据库操作方法，有效地防止数据混乱</li>
</ul>
<p><a href="https://github.com/ccgus/fmdb" target="_blank" rel="external">FMDB的gitHub地址</a></p>
<h3 id="2-核心类"><a href="#2-核心类" class="headerlink" title="2.核心类"></a>2.核心类</h3><p>FMDB有三个主要的类</p>
<ul>
<li><p><strong>FMDatabase</strong></p>
<ul>
<li>一个FMDatabase对象就代表一个单独的SQLite数据库，用来执行SQL语句</li>
</ul>
</li>
<li><p>FMResultSet</p>
<ul>
<li>使用FMDatabase执行查询后的结果集</li>
</ul>
</li>
<li><p>FMDatabaseQueue</p>
<ul>
<li>用于在多线程中执行多个查询或更新，它是线程安全的</li>
</ul>
</li>
</ul>
<h3 id="3-打开数据库"><a href="#3-打开数据库" class="headerlink" title="3.打开数据库"></a>3.打开数据库</h3><p>和c语言框架一样，FMDB通过指定SQLite数据库文件路径来创建FMDatabase对象，但FMDB更加容易理解，使用起来更容易，<strong>使用之前一样需要导入</strong> <code>sqlite3.dylib</code>。打开数据库方法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject stringByAppendingPathComponent:<span class="string">@"person.db"</span>];</span><br><span class="line"></span><br><span class="line">FMDatabase *database = [FMDatabase databaseWithPath:path];    </span><br><span class="line"><span class="keyword">if</span> (![database open]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"数据库打开失败！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，Path的值可以传入一下三种情况</p>
<ul>
<li>具体文件路径，如果不存在会自动创建</li>
<li>空字符串@“”，会在临时目录创建一个空的数据库，当FMDatabase连接关闭时，数据库文件也被删除</li>
<li>nil，会创建一个内存中临时数据库，当FMDatabase连接关闭时，数据库会被销毁</li>
</ul>
<h3 id="4-更新"><a href="#4-更新" class="headerlink" title="4.更新"></a>4.更新</h3><p>在FMDB中，除查询以外的所有操作，都称为“更新”, 如：create、drop、insert、update、delete等操作，使用<code>executeUpdate:</code>方法执行更新：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用方法有以下3种：   </span></span><br><span class="line">- (<span class="built_in">BOOL</span>)executeUpdate:(<span class="built_in">NSString</span>*)sql, ...</span><br><span class="line">- (<span class="built_in">BOOL</span>)executeUpdateWithFormat:(<span class="built_in">NSString</span>*)format, ...</span><br><span class="line">- (<span class="built_in">BOOL</span>)executeUpdate:(<span class="built_in">NSString</span>*)sql withArgumentsInArray:(<span class="built_in">NSArray</span> *)arguments</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">[database executeUpdate:<span class="string">@"CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)"</span>];   </span><br><span class="line"></span><br><span class="line"><span class="comment">//或者  </span></span><br><span class="line">[database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES(?, ?)"</span>, <span class="string">@"Bourne"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">42</span>]];</span><br></pre></td></tr></table></figure>
<h3 id="5-查询"><a href="#5-查询" class="headerlink" title="5.查询"></a>5.查询</h3><p>查询方法也有3种，使用起来相当简单：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (FMResultSet *)executeQuery:(<span class="built_in">NSString</span>*)sql, ...</span><br><span class="line">- (FMResultSet *)executeQueryWithFormat:(<span class="built_in">NSString</span>*)format, ...</span><br><span class="line">- (FMResultSet *)executeQuery:(<span class="built_in">NSString</span> *)sql withArgumentsInArray:(<span class="built_in">NSArray</span> *)arguments</span><br></pre></td></tr></table></figure>
<p>查询示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.执行查询</span></span><br><span class="line">FMResultSet *result = [database executeQuery:<span class="string">@"SELECT * FROM t_person"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.遍历结果集</span></span><br><span class="line"><span class="keyword">while</span> ([result next]) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *name = [result stringForColumn:<span class="string">@"name"</span>];</span><br><span class="line">    <span class="keyword">int</span> age = [result intForColumn:<span class="string">@"age"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-线程安全"><a href="#6-线程安全" class="headerlink" title="6.线程安全"></a>6.线程安全</h3><p>在多个线程中同时使用一个FMDatabase实例是不明智的。不要让多个线程分享同一个FMDatabase实例，它无法在多个线程中同时使用。 如果在多个线程中同时使用一个FMDatabase实例，会造成数据混乱等问题。所以，请使用 FMDatabaseQueue，它是线程安全的。以下是使用方法：</p>
<ul>
<li>创建队列：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];</span><br></pre></td></tr></table></figure>
<ul>
<li>使用队列</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[queue inDatabase:^(FMDatabase *database) &#123;    </span><br><span class="line">          [database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_1"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>]];    </span><br><span class="line">          [database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_2"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">2</span>]];    </span><br><span class="line">          [database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_3"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">3</span>]];      </span><br><span class="line"></span><br><span class="line">          FMResultSet *result = [database executeQuery:<span class="string">@"select * from t_person"</span>];    </span><br><span class="line">         <span class="keyword">while</span>([result next]) &#123;   </span><br><span class="line"></span><br><span class="line">         &#125;    </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>而且可以轻松的把简单任务包装到事务里：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[queue inTransaction:^(FMDatabase *database, <span class="built_in">BOOL</span> *rollback) &#123;    </span><br><span class="line">          [database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_1"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>]];    </span><br><span class="line">          [database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_2"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">2</span>]];    </span><br><span class="line">          [database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_3"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">3</span>]];      </span><br><span class="line"></span><br><span class="line">          FMResultSet *result = [database executeQuery:<span class="string">@"select * from t_person"</span>];    </span><br><span class="line">             <span class="keyword">while</span>([result next]) &#123;   </span><br><span class="line"></span><br><span class="line">             &#125;   </span><br><span class="line"></span><br><span class="line">           <span class="comment">//回滚</span></span><br><span class="line">           *rollback = <span class="literal">YES</span>;  </span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p>FMDatabaseQueue 后台会建立系列化的G-C-D队列，并执行你传给G-C-D队列的块。这意味着 你从多线程同时调用调用方法，GDC也会按它接收的块的顺序来执行。</p>
<p><a href="http://www.jianshu.com/p/7616cbd72845" target="_blank" rel="external">原文地址</a></p>

    
  
</div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2016/06/08/IOS/IOS中数据持久化方式/" data-id="cip86wd8f0005k7bmd08l70gt" class="article-share-link" data-share="baidu" data-title="IOS中数据持久化方式">Share</a>
      

      
        <a href="http://yoursite.com/2016/06/08/IOS/IOS中数据持久化方式/#ds-thread" class="article-comment-link">Comments</a>
      

      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/06/08/IOS/IOS中的加密方式MD5、sha512/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          IOS中的加密方式MD5、sha512
        
      </div>
    </a>
  
  
    <a href="/2016/06/08/IOS/IOS中的正则/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">IOS中的正则</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <div id="ds-thread" class="ds-thread" data-thread-key="2016/06/08/IOS/IOS中数据持久化方式/" data-title="IOS中数据持久化方式" data-url="http://yoursite.com/2016/06/08/IOS/IOS中数据持久化方式/"></div>
  </section>
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IOS/">IOS</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/IOS零碎知识点/">IOS零碎知识点</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MAC系统/">MAC系统</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/UI/">UI</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/常用封装/">常用封装</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/未分类/">未分类</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/行业观点/">行业观点</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">57</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/06/08/PHP/MAC-OS-X上更改XAMPP的根目录/">MAC OS X上更改XAMPP的根目录</a>
          </li>
        
          <li>
            <a href="/2016/06/08/行业观点/10亿红包从天而降，揭秘微信摇一摇背后的技术细节/">10亿红包从天而降，揭秘微信摇一摇背后的技术细节</a>
          </li>
        
          <li>
            <a href="/2016/06/08/IOS/-iOS-录音-上传与播放解析/">iOS 录音-上传与播放解析</a>
          </li>
        
          <li>
            <a href="/2016/06/08/IOS/IOS中的加密方式MD5、sha512/">IOS中的加密方式MD5、sha512</a>
          </li>
        
          <li>
            <a href="/2016/06/08/IOS/IOS中数据持久化方式/">IOS中数据持久化方式</a>
          </li>
        
      </ul>
    </div>

    <div>
    <a href="http://s.click.taobao.com/t?e=m%3D2%26s%3DxlVfYXp9ADwcQipKwQzePOeEDrYVVa64LKpWJ%2Bin0XLjf2vlNIV67lLJMA%2Bho7WYmSMhGfkQJ74bkh964woV3ioLW0YUqK3wnwlhM%2BcmZI9%2F94Eih2V31gk4WEl1q9KXrO7VWU786ernpVPht%2FCebGyQXcCgqLpl&pvid=10_116.237.201.134_8763_1465440920643"><img style="margin:0 10px 0 0;" width="275" height="275" src="http://7d9kpb.com1.z0.glb.clouddn.com/%E5%A5%BD%E8%A7%86%E5%8A%9B.jpg"></a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Links</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://www.yuanjunliang.cn/" target="_blank">袁俊亮个人博客</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 袁俊亮<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="totop"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"junliangyuan"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js"></script>

</div>
</body>
</html>
